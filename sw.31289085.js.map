{"mappings":"ACEA,MAAM,EAAa,SAEb,EAAc,aAEpB,KAAK,iBAAiB,UAAW,SAAS,CAAK,EAC7C,QAAQ,IAAI,2BAEZ,EAAM,UAAU,AAAC,CAAA,UACf,IAAM,EAAQ,MAAM,OAAO,KAAK,EAGhC,OAAM,EAAM,IAAI,IAAI,QAAQ,EAAa,CAAC,MAAO,QAAQ,GAC3D,CAAA,KAEA,KAAK,aACP,GAEA,KAAK,iBAAiB,WAAY,AAAC,IACjC,QAAQ,IAAI,4BACZ,EAAM,UAAU,AAAC,CAAA,UAGX,sBAAuB,KAAK,cAC9B,MAAM,KAAK,aAAa,kBAAkB,QAE9C,CAAA,KAGA,KAAK,QAAQ,OACf,GAGA,KAAK,iBAAiB,QAAS,AAAA,IACF,aAAvB,EAAM,QAAQ,MAChB,EAAM,YAAa,AAAA,CAAA,UACjB,GAAI,CACF,IAAM,EAAkB,MAAM,EAAM,gBACpC,GAAI,EACF,OAAO,EAGT,IAAM,EAAkB,MAAM,MAAM,EAAM,SAC1C,OAAO,CACT,CAAE,MAAO,EAAO,CACd,QAAQ,IAAI,iEAAkE,GAE9E,IAAM,EAAQ,MAAM,OAAO,KAAK,GAC1B,EAAiB,MAAM,EAAM,MAAM,GACzC,OAAO,CACT,CACF,CAAA,IAEJ","sources":["<anon>","src/sw.js"],"sourcesContent":["var $9f6538ba86e4d72c$exports = {};\nconst $9f6538ba86e4d72c$var$VERSION = 1;\n// Define the cache name\nconst $9f6538ba86e4d72c$var$CACHE_NAME = `psd-v${$9f6538ba86e4d72c$var$VERSION}`;\nconst $9f6538ba86e4d72c$var$OFFLINE_URL = \"index.html\";\nself.addEventListener(\"install\", function(event) {\n    console.log(\"[ServiceWorker] Install\");\n    event.waitUntil((async ()=>{\n        const cache = await caches.open($9f6538ba86e4d72c$var$CACHE_NAME);\n        // Setting {cache: 'reload'} in the new request will ensure that the response\n        // isn't fulfilled from the HTTP cache; i.e., it will be from the network.\n        await cache.add(new Request($9f6538ba86e4d72c$var$OFFLINE_URL, {\n            cache: \"reload\"\n        }));\n    })());\n    self.skipWaiting();\n});\nself.addEventListener(\"activate\", (event)=>{\n    console.log(\"[ServiceWorker] Activate\");\n    event.waitUntil((async ()=>{\n        // Enable navigation preload if it's supported.\n        // See https://developers.google.com/web/updates/2017/02/navigation-preload\n        if (\"navigationPreload\" in self.registration) await self.registration.navigationPreload.enable();\n    })());\n    // Tell the active service worker to take control of the page immediately.\n    self.clients.claim();\n});\n// Serve cached content when offline\nself.addEventListener(\"fetch\", (event)=>{\n    if (event.request.mode === \"navigate\") event.respondWith((async ()=>{\n        try {\n            const preloadResponse = await event.preloadResponse;\n            if (preloadResponse) return preloadResponse;\n            const networkResponse = await fetch(event.request);\n            return networkResponse;\n        } catch (error) {\n            console.log(\"[Service Worker] Fetch failed; returning offline page instead.\", error);\n            const cache = await caches.open($9f6538ba86e4d72c$var$CACHE_NAME);\n            const cachedResponse = await cache.match($9f6538ba86e4d72c$var$OFFLINE_URL);\n            return cachedResponse;\n        }\n    })());\n});\n\n\n//# sourceMappingURL=sw.31289085.js.map\n","const VERSION = 1;\n// Define the cache name\nconst CACHE_NAME = `psd-v${VERSION}`;\n\nconst OFFLINE_URL = 'index.html';\n\nself.addEventListener('install', function(event) {\n  console.log('[ServiceWorker] Install');\n  \n  event.waitUntil((async () => {\n    const cache = await caches.open(CACHE_NAME);\n    // Setting {cache: 'reload'} in the new request will ensure that the response\n    // isn't fulfilled from the HTTP cache; i.e., it will be from the network.\n    await cache.add(new Request(OFFLINE_URL, {cache: 'reload'}));\n  })());\n  \n  self.skipWaiting();\n});\n\nself.addEventListener('activate', (event) => {\n  console.log('[ServiceWorker] Activate');\n  event.waitUntil((async () => {\n    // Enable navigation preload if it's supported.\n    // See https://developers.google.com/web/updates/2017/02/navigation-preload\n    if ('navigationPreload' in self.registration) {\n      await self.registration.navigationPreload.enable();\n    }\n  })());\n\n  // Tell the active service worker to take control of the page immediately.\n  self.clients.claim();\n});\n\n// Serve cached content when offline\nself.addEventListener('fetch', event => {\n  if (event.request.mode === 'navigate') {\n    event.respondWith((async () => {\n      try {\n        const preloadResponse = await event.preloadResponse;\n        if (preloadResponse) {\n          return preloadResponse;\n        }\n\n        const networkResponse = await fetch(event.request);\n        return networkResponse;\n      } catch (error) {\n        console.log('[Service Worker] Fetch failed; returning offline page instead.', error);\n\n        const cache = await caches.open(CACHE_NAME);\n        const cachedResponse = await cache.match(OFFLINE_URL);\n        return cachedResponse;\n      }\n    })());\n  }\n});\n"],"names":["$9f6538ba86e4d72c$var$CACHE_NAME","$9f6538ba86e4d72c$var$OFFLINE_URL","self","addEventListener","event","console","log","waitUntil","cache","caches","open","add","Request","skipWaiting","registration","navigationPreload","enable","clients","claim","request","mode","respondWith","preloadResponse","networkResponse","fetch","error","cachedResponse","match"],"version":3,"file":"sw.31289085.js.map"}